'use strict';

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports._installNpmLibDef = exports._installNpmLibDefs = exports._determineFlowVersion = exports.description = exports.name = undefined;

var _slicedToArray = function () { function sliceIterator(arr, i) { var _arr = []; var _n = true; var _d = false; var _e = undefined; try { for (var _i = arr[Symbol.iterator](), _s; !(_n = (_s = _i.next()).done); _n = true) { _arr.push(_s.value); if (i && _arr.length === i) break; } } catch (err) { _d = true; _e = err; } finally { try { if (!_n && _i["return"]) _i["return"](); } finally { if (_d) throw _e; } } return _arr; } return function (arr, i) { if (Array.isArray(arr)) { return arr; } else if (Symbol.iterator in Object(arr)) { return sliceIterator(arr, i); } else { throw new TypeError("Invalid attempt to destructure non-iterable instance"); } }; }();

exports.setup = setup;
exports.run = run;

var _codeSign = require('../lib/codeSign');

var _fileUtils = require('../lib/fileUtils');

var _flowProjectUtils = require('../lib/flowProjectUtils');

var _flowVersion = require('../lib/flowVersion');

var _node = require('../lib/node');

var _npmLibDefs = require('../lib/npm/npmLibDefs');

var _npmProjectUtils = require('../lib/npm/npmProjectUtils');

var _cacheRepoUtils = require('../lib/cacheRepoUtils');

var _semver = require('../lib/semver');

var _safe = require('colors/safe');

var _safe2 = _interopRequireDefault(_safe);

var _semver2 = require('semver');

var _semver3 = _interopRequireDefault(_semver2);

var _stubUtils = require('../lib/stubUtils');

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

function _toConsumableArray(arr) { if (Array.isArray(arr)) { for (var i = 0, arr2 = Array(arr.length); i < arr.length; i++) { arr2[i] = arr[i]; } return arr2; } else { return Array.from(arr); } }

var name = exports.name = 'install';
var description = exports.description = 'Installs libdefs into the ./flow-typed directory';
function setup(yargs) {
  return yargs.usage('$0 ' + name + ' - ' + description).options({
    flowVersion: {
      alias: 'f',
      describe: 'The Flow version that fetched libdefs must be compatible ' + 'with',
      type: 'string'
    },
    verbose: {
      describe: 'Print additional, verbose info while installing libdefs',
      type: 'boolean',
      demand: false
    },
    skip: {
      alias: 's',
      describe: 'Do not generate stubs for missing libdefs',
      type: 'boolean',
      demand: false
    },
    libdefDir: {
      alias: 'l',
      describe: 'Use a custom directory to install libdefs',
      type: 'string',
      demand: false
    },
    cacheDir: {
      alias: 'c',
      describe: 'Directory (absolute or relative path, ~ is not supported) to store cache of libdefs',
      type: 'string',
      demand: false
    },
    packageDir: {
      alias: 'p',
      describe: 'The relative path of package.json where flow-bin is installed',
      type: 'string'
    },
    ignoreDeps: {
      alias: 'i',
      describe: 'Dependency categories to ignore when installing definitions',
      type: 'array'
    },
    rootDir: {
      alias: 'r',
      describe: 'Directory of .flowconfig relative to node_modules',
      type: 'string'
    }
  });
}
function run(args) {
  var cwd, packageDir, flowVersion, libdefDir, explicitLibDefs, ignoreDeps, coreLibDefResult, _cacheDir, npmLibDefResult;

  return regeneratorRuntime.async(function run$(_context) {
    while (1) {
      switch (_context.prev = _context.next) {
        case 0:
          cwd = args.rootDir ? _node.path.resolve(args.rootDir) : process.cwd();
          packageDir = args.packageDir ? _node.path.resolve(args.packageDir) : cwd;
          _context.next = 4;
          return regeneratorRuntime.awrap(determineFlowVersion(packageDir, args.flowVersion));

        case 4:
          flowVersion = _context.sent;
          libdefDir = args.libdefDir || 'flow-typed';
          explicitLibDefs = args._.slice(1);
          ignoreDeps = args.ignoreDeps || [];
          _context.next = 10;
          return regeneratorRuntime.awrap(installCoreLibDefs());

        case 10:
          coreLibDefResult = _context.sent;

          if (!(coreLibDefResult !== 0)) {
            _context.next = 13;
            break;
          }

          return _context.abrupt('return', coreLibDefResult);

        case 13:

          if (args.cacheDir) {
            _cacheDir = _node.path.resolve(args.cacheDir);

            console.log('• Setting cache dir', _cacheDir);
            (0, _cacheRepoUtils._setCustomCacheDir)(_cacheDir);
          }

          _context.next = 16;
          return regeneratorRuntime.awrap(installNpmLibDefs({
            cwd: cwd,
            flowVersion: flowVersion,
            explicitLibDefs: explicitLibDefs,
            libdefDir: libdefDir,
            verbose: args.verbose,
            overwrite: args.overwrite,
            skip: args.skip,
            ignoreDeps: ignoreDeps
          }));

        case 16:
          npmLibDefResult = _context.sent;

          if (!(npmLibDefResult !== 0)) {
            _context.next = 19;
            break;
          }

          return _context.abrupt('return', npmLibDefResult);

        case 19:
          return _context.abrupt('return', 0);

        case 20:
        case 'end':
          return _context.stop();
      }
    }
  }, null, this);
}

function determineFlowVersion(cwd, flowVersionArg) {
  var flowVersionStr;
  return regeneratorRuntime.async(function determineFlowVersion$(_context2) {
    while (1) {
      switch (_context2.prev = _context2.next) {
        case 0:
          if (!(flowVersionArg != null)) {
            _context2.next = 6;
            break;
          }

          // Be permissive if the prefix 'v' is left off
          flowVersionStr = flowVersionArg[0] === 'v' ? flowVersionArg : 'v' + flowVersionArg;


          if (/^v[0-9]+\.[0-9]+$/.test(flowVersionStr)) {
            flowVersionStr = flowVersionStr + '.0';
          }

          return _context2.abrupt('return', {
            kind: 'specific',
            ver: (0, _flowVersion.parseFlowSpecificVer)(flowVersionStr, flowVersionArg)
          });

        case 6:
          _context2.next = 8;
          return regeneratorRuntime.awrap((0, _npmProjectUtils.findFlowSpecificVer)(cwd));

        case 8:
          _context2.t0 = _context2.sent;
          return _context2.abrupt('return', {
            kind: 'specific',
            ver: _context2.t0
          });

        case 10:
        case 'end':
          return _context2.stop();
      }
    }
  }, null, this);
}

function installCoreLibDefs() {
  return regeneratorRuntime.async(function installCoreLibDefs$(_context3) {
    while (1) {
      switch (_context3.prev = _context3.next) {
        case 0:
          return _context3.abrupt('return', 0);

        case 1:
        case 'end':
          return _context3.stop();
      }
    }
  }, null, this);
}

var FLOW_BUILT_IN_NPM_LIBS = ['react', 'react-dom'];

function installNpmLibDefs(_ref) {
  var _this = this;

  var cwd = _ref.cwd,
      flowVersion = _ref.flowVersion,
      explicitLibDefs = _ref.explicitLibDefs,
      libdefDir = _ref.libdefDir,
      verbose = _ref.verbose,
      overwrite = _ref.overwrite,
      skip = _ref.skip,
      ignoreDeps = _ref.ignoreDeps;

  var flowProjectRoot, libdefsToSearchFor, i, term, termMatches, pkgJsonData, pkgJsonDeps, packageVersion, _termMatches, _2, npmScope, pkgName, pkgVerStr, scopedPkgName, _pkgJsonData, _pkgJsonDeps, _pkgName, libDefsToSearchForEntries, libDefsToInstall, outdatedLibDefsToInstall, unavailableLibDefs, libDefsToUninstall, alreadyInstalledLibDefs, flowTypedDirPath, results, untypedMissingLibDefs, typedMissingLibDefs, plural;

  return regeneratorRuntime.async(function installNpmLibDefs$(_context8) {
    while (1) {
      switch (_context8.prev = _context8.next) {
        case 0:
          _context8.next = 2;
          return regeneratorRuntime.awrap((0, _flowProjectUtils.findFlowRoot)(cwd));

        case 2:
          flowProjectRoot = _context8.sent;

          if (!(flowProjectRoot === null)) {
            _context8.next = 6;
            break;
          }

          console.error('Error: Unable to find a flow project in the current dir or any of ' + "it's parent dirs!\n" + 'Please run this command from within a Flow project.');
          return _context8.abrupt('return', 1);

        case 6:
          libdefsToSearchFor = new Map();

          // If a specific pkg/version was specified, only add those packages.
          // Otherwise, extract dependencies from the package.json

          if (!(explicitLibDefs.length > 0)) {
            _context8.next = 35;
            break;
          }

          i = 0;

        case 9:
          if (!(i < explicitLibDefs.length)) {
            _context8.next = 32;
            break;
          }

          term = explicitLibDefs[i];
          termMatches = term.match(/(@[^@\/]+\/)?([^@]+)@(.+)/);

          if (!(termMatches == null)) {
            _context8.next = 26;
            break;
          }

          _context8.next = 15;
          return regeneratorRuntime.awrap((0, _npmProjectUtils.getPackageJsonData)(cwd));

        case 15:
          pkgJsonData = _context8.sent;
          pkgJsonDeps = (0, _npmProjectUtils.getPackageJsonDependencies)(pkgJsonData, []);
          packageVersion = pkgJsonDeps[term];

          if (!packageVersion) {
            _context8.next = 22;
            break;
          }

          libdefsToSearchFor.set(term, packageVersion);
          _context8.next = 24;
          break;

        case 22:
          console.error('ERROR: Package not found from package.json.\n' + 'Please specify version for the package in the format of `foo@1.2.3`');
          return _context8.abrupt('return', 1);

        case 24:
          _context8.next = 29;
          break;

        case 26:
          _termMatches = _slicedToArray(termMatches, 4), _2 = _termMatches[0], npmScope = _termMatches[1], pkgName = _termMatches[2], pkgVerStr = _termMatches[3];
          scopedPkgName = npmScope != null ? npmScope + pkgName : pkgName;

          libdefsToSearchFor.set(scopedPkgName, pkgVerStr);

        case 29:
          i++;
          _context8.next = 9;
          break;

        case 32:
          console.log('\u2022 Searching for ' + libdefsToSearchFor.size + ' libdefs...');
          _context8.next = 44;
          break;

        case 35:
          _context8.next = 37;
          return regeneratorRuntime.awrap((0, _npmProjectUtils.getPackageJsonData)(cwd));

        case 37:
          _pkgJsonData = _context8.sent;
          _pkgJsonDeps = (0, _npmProjectUtils.getPackageJsonDependencies)(_pkgJsonData, ignoreDeps);

          for (_pkgName in _pkgJsonDeps) {
            libdefsToSearchFor.set(_pkgName, _pkgJsonDeps[_pkgName]);
          }

          if (!(libdefsToSearchFor.size === 0)) {
            _context8.next = 43;
            break;
          }

          console.error("No dependencies were found in this project's package.json!");
          return _context8.abrupt('return', 0);

        case 43:

          if (verbose) {
            libdefsToSearchFor.forEach(function (ver, name) {
              console.log('\u2022 Found package.json dependency: ' + name + '@' + ver);
            });
          } else {
            console.log('\u2022 Found ' + libdefsToSearchFor.size + ' dependencies in package.json to ' + 'install libdefs for. Searching...');
          }

        case 44:
          libDefsToSearchForEntries = [].concat(_toConsumableArray(libdefsToSearchFor.entries()));

          // Search for the requested libdefs

          libDefsToInstall = new Map();
          outdatedLibDefsToInstall = [];
          unavailableLibDefs = [];
          _context8.next = 50;
          return regeneratorRuntime.awrap(Promise.all(libDefsToSearchForEntries.map(function _callee(_ref2) {
            var _ref3 = _slicedToArray(_ref2, 2),
                name = _ref3[0],
                ver = _ref3[1];

            var libDef, libDefLower, depLower;
            return regeneratorRuntime.async(function _callee$(_context4) {
              while (1) {
                switch (_context4.prev = _context4.next) {
                  case 0:
                    if (!(FLOW_BUILT_IN_NPM_LIBS.indexOf(name) !== -1)) {
                      _context4.next = 2;
                      break;
                    }

                    return _context4.abrupt('return');

                  case 2:
                    _context4.next = 4;
                    return regeneratorRuntime.awrap((0, _npmLibDefs.findNpmLibDef)(name, ver, flowVersion));

                  case 4:
                    libDef = _context4.sent;

                    if (libDef === null) {
                      unavailableLibDefs.push({ name: name, ver: ver });
                    } else {
                      libDefsToInstall.set(name, libDef);

                      // If the libdef is outdated (but still compatible), note this so we can
                      // warn the user
                      libDefLower = (0, _semver.getRangeLowerBound)(libDef.version);
                      depLower = (0, _semver.getRangeLowerBound)(ver);

                      if (_semver3.default.lt(libDefLower, depLower)) {
                        outdatedLibDefsToInstall.push([libDef, { name: name, ver: ver }]);
                      }
                    }

                  case 6:
                  case 'end':
                    return _context4.stop();
                }
              }
            }, null, _this);
          })));

        case 50:

          // Scan libdefs that are already installed
          libDefsToUninstall = new Map();
          _context8.next = 53;
          return regeneratorRuntime.awrap((0, _npmLibDefs.getInstalledNpmLibDefs)(_node.path.join(flowProjectRoot), libdefDir));

        case 53:
          alreadyInstalledLibDefs = _context8.sent;

          [].concat(_toConsumableArray(alreadyInstalledLibDefs.entries())).forEach(function (_ref4) {
            var _ref5 = _slicedToArray(_ref4, 2),
                filePath = _ref5[0],
                npmLibDef = _ref5[1];

            var fullFilePath = _node.path.join(flowProjectRoot, filePath);
            switch (npmLibDef.kind) {
              case 'LibDef':
                // If a libdef is already installed for some dependency, we need to
                // uninstall it before installing the new (potentially updated) ver
                var libDef = npmLibDef.libDef;
                var _scopedPkgName = (0, _npmLibDefs.getScopedPackageName)(libDef);
                if (libDefsToInstall.has(_scopedPkgName)) {
                  libDefsToUninstall.set(_scopedPkgName, fullFilePath);
                }
                break;

              case 'Stub':
                break;

              default:
                npmLibDef;
            }
          });

          if (!(libDefsToInstall.size > 0)) {
            _context8.next = 65;
            break;
          }

          console.log('\u2022 Installing ' + libDefsToInstall.size + ' libDefs...');
          flowTypedDirPath = _node.path.join(flowProjectRoot, libdefDir, 'npm');
          _context8.next = 60;
          return regeneratorRuntime.awrap((0, _fileUtils.mkdirp)(flowTypedDirPath));

        case 60:
          _context8.next = 62;
          return regeneratorRuntime.awrap(Promise.all([].concat(_toConsumableArray(libDefsToInstall.values())).map(function _callee2(libDef) {
            var toUninstall;
            return regeneratorRuntime.async(function _callee2$(_context5) {
              while (1) {
                switch (_context5.prev = _context5.next) {
                  case 0:
                    toUninstall = libDefsToUninstall.get((0, _npmLibDefs.getScopedPackageName)(libDef));

                    if (!(toUninstall != null)) {
                      _context5.next = 4;
                      break;
                    }

                    _context5.next = 4;
                    return regeneratorRuntime.awrap(_node.fs.unlink(toUninstall));

                  case 4:
                    return _context5.abrupt('return', installNpmLibDef(libDef, flowTypedDirPath, overwrite));

                  case 5:
                  case 'end':
                    return _context5.stop();
                }
              }
            }, null, _this);
          })));

        case 62:
          results = _context8.sent;

          if (!results.some(function (res) {
            return !res;
          })) {
            _context8.next = 65;
            break;
          }

          return _context8.abrupt('return', 1);

        case 65:

          if ((verbose || unavailableLibDefs.length === 0) && outdatedLibDefsToInstall.length > 0) {
            console.log('• The following installed libdefs are compatible with your ' + 'dependencies, but may not include all minor and patch changes for ' + 'your specific dependency version:\n');
            outdatedLibDefsToInstall.forEach(function (_ref6) {
              var _ref7 = _slicedToArray(_ref6, 2),
                  libDef = _ref7[0],
                  _ref7$ = _ref7[1],
                  pkgName = _ref7$.name,
                  pkgVersion = _ref7$.ver;

              console.log('  • libdef: %s (satisfies %s)', _safe2.default.yellow(libDef.name + '_' + libDef.version), _safe2.default.bold(pkgName + '@' + pkgVersion));

              var libDefPlural = outdatedLibDefsToInstall.length > 1 ? ['versioned updates', 'these packages'] : ['a versioned update', 'this package'];
              console.log('\n' + ('  Consider submitting ' + libDefPlural[0] + ' for ' + libDefPlural[1] + ' to \n') + '  https://github.com/flowtype/flow-typed/\n');
            });
          }

          if (!(unavailableLibDefs.length > 0 && unavailableLibDefs.length === explicitLibDefs.length)) {
            _context8.next = 71;
            break;
          }

          // If the user specified an explicit library to be installed, don't generate
          // a stub if no libdef exists -- just inform them that one doesn't exist
          console.log(_safe2.default.red('!! No flow@' + (0, _flowVersion.toSemverString)(flowVersion) + '-compatible libdefs ' + 'found in flow-typed for the explicitly requested libdefs. !!') + '\n' + '\n' + 'Consider using `%s` to generate an empty libdef that you can fill in.', _safe2.default.bold('flow-typed create-stub ' + explicitLibDefs.join(' ')));

          return _context8.abrupt('return', 1);

        case 71:
          // If a package that's missing a flow-typed libdef has any .flow files,
          // we'll skip generating a stub for it.
          untypedMissingLibDefs = [];
          typedMissingLibDefs = [];
          _context8.next = 75;
          return regeneratorRuntime.awrap(Promise.all(unavailableLibDefs.map(function _callee3(_ref8) {
            var pkgName = _ref8.name,
                pkgVer = _ref8.ver;
            var hasFlowFiles;
            return regeneratorRuntime.async(function _callee3$(_context6) {
              while (1) {
                switch (_context6.prev = _context6.next) {
                  case 0:
                    _context6.next = 2;
                    return regeneratorRuntime.awrap((0, _stubUtils.pkgHasFlowFiles)(cwd, pkgName));

                  case 2:
                    hasFlowFiles = _context6.sent;

                    if (hasFlowFiles) {
                      typedMissingLibDefs.push([pkgName, pkgVer]);
                    } else {
                      untypedMissingLibDefs.push([pkgName, pkgVer]);
                    }

                  case 4:
                  case 'end':
                    return _context6.stop();
                }
              }
            }, null, _this);
          })));

        case 75:
          if (!(untypedMissingLibDefs.length > 0 && !skip)) {
            _context8.next = 82;
            break;
          }

          console.log('• Generating stubs for untyped dependencies...');
          _context8.next = 79;
          return regeneratorRuntime.awrap(Promise.all(untypedMissingLibDefs.map(function _callee4(_ref9) {
            var _ref10 = _slicedToArray(_ref9, 2),
                pkgName = _ref10[0],
                pkgVerStr = _ref10[1];

            return regeneratorRuntime.async(function _callee4$(_context7) {
              while (1) {
                switch (_context7.prev = _context7.next) {
                  case 0:
                    _context7.next = 2;
                    return regeneratorRuntime.awrap((0, _stubUtils.createStub)(flowProjectRoot, pkgName, pkgVerStr, overwrite, libdefDir));

                  case 2:
                  case 'end':
                    return _context7.stop();
                }
              }
            }, null, _this);
          })));

        case 79:

          console.log(_safe2.default.red('\n!! No flow@' + (0, _flowVersion.toSemverString)(flowVersion) + '-compatible libdefs ' + 'found in flow-typed for the above untyped dependencies !!'));

          plural = unavailableLibDefs.length > 1 ? ['libdefs', 'these packages', 'them'] : ['a libdef', 'this package', 'it'];

          console.log('\n' + ('I\'ve generated ' + '`' + 'any' + '`' + '-typed stubs for ' + plural[1] + ', but ') + 'consider submitting \n' + (plural[0] + ' for ' + plural[2] + ' to ') + (_safe2.default.bold('https://github.com/flowtype/flow-typed/') + '\n'));

        case 82:
          return _context8.abrupt('return', 0);

        case 83:
        case 'end':
          return _context8.stop();
      }
    }
  }, null, this);
}

function installNpmLibDef(npmLibDef, npmDir, overwrite) {
  var scopedDir, fileName, filePath, terseFilePath, repoVersion, codeSignPreprocessor, stubName, stubPath;
  return regeneratorRuntime.async(function installNpmLibDef$(_context9) {
    while (1) {
      switch (_context9.prev = _context9.next) {
        case 0:
          scopedDir = npmLibDef.scope === null ? npmDir : _node.path.join(npmDir, npmLibDef.scope);

          (0, _fileUtils.mkdirp)(scopedDir);

          fileName = npmLibDef.name + '_' + npmLibDef.version + '.js';
          filePath = _node.path.join(scopedDir, fileName);

          // Find the libDef in the cached repo

          _context9.prev = 4;
          terseFilePath = _node.path.relative(_node.path.resolve(npmDir, '..', '..'), filePath);
          _context9.t0 = !overwrite;

          if (!_context9.t0) {
            _context9.next = 11;
            break;
          }

          _context9.next = 10;
          return regeneratorRuntime.awrap(_node.fs.exists(filePath));

        case 10:
          _context9.t0 = _context9.sent;

        case 11:
          if (!_context9.t0) {
            _context9.next = 14;
            break;
          }

          console.error('  • %s\n' + '    %s\n    %s\n    └> %s', _safe2.default.bold(_safe2.default.red(terseFilePath + ' already exists and appears to have been manually ' + 'written or changed!')), _safe2.default.green('Consider contributing your changes back to flow-typed repository :)'), 'Read more at https://github.com/flowtype/flow-typed/wiki/Contributing-Library-Definitions', 'Use --overwrite to overwrite the existing libdef.');
          return _context9.abrupt('return', true);

        case 14:
          _context9.next = 16;
          return regeneratorRuntime.awrap((0, _npmLibDefs.getNpmLibDefVersionHash)((0, _cacheRepoUtils.getCacheRepoDir)(), npmLibDef));

        case 16:
          repoVersion = _context9.sent;
          codeSignPreprocessor = (0, _codeSign.signCodeStream)(repoVersion);
          _context9.next = 20;
          return regeneratorRuntime.awrap((0, _fileUtils.copyFile)(npmLibDef.path, filePath, codeSignPreprocessor));

        case 20:

          console.log(_safe2.default.bold('  • %s\n' + '    └> %s'), fileName, _safe2.default.green('.' + _node.path.sep + terseFilePath));

          // Remove any lingering stubs
          console.log(npmLibDef.name);
          console.log(scopedDir);
          stubName = npmLibDef.name + '_vx.x.x.js';
          stubPath = _node.path.join(scopedDir, stubName);
          _context9.t1 = overwrite;

          if (!_context9.t1) {
            _context9.next = 30;
            break;
          }

          _context9.next = 29;
          return regeneratorRuntime.awrap(_node.fs.exists(stubPath));

        case 29:
          _context9.t1 = _context9.sent;

        case 30:
          if (!_context9.t1) {
            _context9.next = 33;
            break;
          }

          _context9.next = 33;
          return regeneratorRuntime.awrap(_node.fs.unlink(stubPath));

        case 33:
          return _context9.abrupt('return', true);

        case 36:
          _context9.prev = 36;
          _context9.t2 = _context9['catch'](4);

          console.error('  !! Failed to install ' + npmLibDef.name + ' at ' + filePath);
          console.error('  ERROR: ' + _context9.t2.message);
          return _context9.abrupt('return', false);

        case 41:
        case 'end':
          return _context9.stop();
      }
    }
  }, null, this, [[4, 36]]);
}

exports._determineFlowVersion = determineFlowVersion;
exports._installNpmLibDefs = installNpmLibDefs;
exports._installNpmLibDef = installNpmLibDef;